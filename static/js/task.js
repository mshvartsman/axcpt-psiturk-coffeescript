// Generated by CoffeeScript 1.9.1

/*
A fairly direct port of the Python `random` module to JavaScript
 */

(function() {
  var BaseRandom, BuiltinRandom, DotsExperiment, Experiment, ExtMath, HighQualityRandom, LOG2E, LettersExperiment, NotImplementedError, POW_32, POW_NEG_32, PracticeTrial, Random, Renderer, TestTrial, Trial, acos, base, bind, cos, exp, exports, extend, floor, lg, log, mod, pow, random, sqrt,
    slice = [].slice,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind1 = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  log = Math.log, sqrt = Math.sqrt, cos = Math.cos, acos = Math.acos, floor = Math.floor, pow = Math.pow, LOG2E = Math.LOG2E, exp = Math.exp;

  POW_32 = pow(2, 32);

  POW_NEG_32 = pow(2, -32);

  lg = function(x) {
    return (LOG2E * log(x + 1e-10)) >> 0;
  };

  mod = function(x, y) {
    var jsmod;
    if (!((jsmod = x % y) && (x > 0 ^ y > 0))) {
      return jsmod;
    } else {
      return jsmod + y;
    }
  };

  extend = function() {
    var l, len, method, name, obj, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (l = 0, len = sources.length; l < len; l++) {
      obj = sources[l];
      for (name in obj) {
        method = obj[name];
        target[name] = method;
      }
    }
    return target;
  };

  bind = function(fn, obj) {
    return function() {
      return fn.apply(obj, arguments);
    };
  };

  NotImplementedError = (function(superClass) {
    extend1(NotImplementedError, superClass);

    function NotImplementedError() {
      return NotImplementedError.__super__.constructor.apply(this, arguments);
    }

    return NotImplementedError;

  })(Error);

  BaseRandom = (function() {
    var E, LOG4, POW_NEG_26, POW_NEG_27, SG_MAGICCONST, TAU, _bits;

    BaseRandom.prototype._randint32 = function() {
      throw new NotImplementedError;
    };

    BaseRandom.prototype._getstate = function() {
      throw new NotImplementedError;
    };

    BaseRandom.prototype._setstate = function(state) {
      throw new NotImplementedError;
    };

    BaseRandom.prototype._seed = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      throw new NotImplementedError;
    };

    function BaseRandom() {
      this.weibullvariate = bind1(this.weibullvariate, this);
      this.paretovariate = bind1(this.paretovariate, this);
      this.betavariate = bind1(this.betavariate, this);
      this.gammavariate = bind1(this.gammavariate, this);
      this.vonmisesvariate = bind1(this.vonmisesvariate, this);
      this.expovariate = bind1(this.expovariate, this);
      this.lognormvariate = bind1(this.lognormvariate, this);
      this.triangular = bind1(this.triangular, this);
      this.gauss = bind1(this.gauss, this);
      this.shuffle = bind1(this.shuffle, this);
      this.sample = bind1(this.sample, this);
      this.choice = bind1(this.choice, this);
      this.randint = bind1(this.randint, this);
      this.randrange = bind1(this.randrange, this);
      this.uniform = bind1(this.uniform, this);
      this.getstate = bind1(this.getstate, this);
      this.setstate = bind1(this.setstate, this);
      this.random = bind1(this.random, this);
      this.seed = bind1(this.seed, this);
      this.normalvariate = bind(this.normalvariate, this);
      this._next_gauss = null;
      this.seed(+(new Date));
    }

    BaseRandom.prototype.seed = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this._seed.apply(this, args);
    };

    POW_NEG_26 = pow(2, -26);

    POW_NEG_27 = pow(2, -27);

    BaseRandom.prototype.random = function() {
      var high_bits, low_bits;
      low_bits = this._randint32() >>> 6;
      high_bits = this._randint32() >>> 5;
      return (high_bits + low_bits * POW_NEG_26) * POW_NEG_27;
    };

    BaseRandom.prototype.setstate = function(arg) {
      var state;
      this._next_gauss = arg[0], state = 2 <= arg.length ? slice.call(arg, 1) : [];
      return this._setstate(state);
    };

    BaseRandom.prototype.getstate = function() {
      return [this._next_gauss].concat(slice.call(this._getstate()));
    };

    _bits = {};

    BaseRandom.prototype._randbelow = function(n) {
      var bits, r;
      if (n <= 0x100000000) {
        bits = _bits[n] || (_bits[n] = (lg(n - 1)) + 1);
        while (true) {
          r = this._randint32() >>> (32 - bits);
          if (r < 0) {
            r += POW_32;
          }
          if (r < n) {
            break;
          }
        }
        return r;
      } else {
        return floor(this.random() * n);
      }
    };

    BaseRandom.prototype.uniform = function(a, b) {
      return a + this.random() * (b - a);
    };

    BaseRandom.prototype.randrange = function(start, stop, step) {
      if (stop == null) {
        return this._randbelow(start);
      } else if (!step) {
        return start + this._randbelow(stop - start);
      } else {
        return start + step * this._randbelow(floor((stop - start) / step));
      }
    };

    BaseRandom.prototype.randint = function(a, b) {
      return a + this._randbelow(1 + b - a);
    };

    BaseRandom.prototype.choice = function(seq) {
      return seq[this._randbelow(seq.length)];
    };

    BaseRandom.prototype.sample = function(population, k) {
      var i, j, l, n, o, pool, ref, ref1, ref2, ref3, results, results1, selected, val;
      if (k == null) {
        k = 1;
      }
      n = population.length;
      if (k > n) {
        throw new Error("can't take a sample bigger than the population");
      }
      if (k * 3 > n) {
        pool = slice.call(population);
        results = [];
        for (i = l = ref = n, ref1 = n - k; l > ref1; i = l += -1) {
          j = this._randbelow(i);
          val = pool[j];
          pool[j] = pool[i - 1];
          results.push(val);
        }
        return results;
      } else {
        selected = [];
        results1 = [];
        for (i = o = 0, ref2 = k; o < ref2; i = o += 1) {
          while (true) {
            if (ref3 = (j = this._randbelow(n)), indexOf.call(selected, ref3) < 0) {
              break;
            }
          }
          selected.push(j);
          results1.push(population[j]);
        }
        return results1;
      }
    };

    BaseRandom.prototype.shuffle = function(x) {
      var i, j, l, ref, tmp;
      for (i = l = ref = x.length - 1; l >= 1; i = l += -1) {
        j = this._randbelow(i + 1);
        tmp = x[i];
        x[i] = x[j];
        x[j] = tmp;
      }
      return x;
    };

    BaseRandom.prototype.gauss = function(mu, sigma) {
      var s, u, v, w, z;
      if (mu == null) {
        mu = 0;
      }
      if (sigma == null) {
        sigma = 1;
      }
      if ((z = this._next_gauss) != null) {
        this._next_gauss = null;
      } else {
        while (!(s && s < 1)) {
          u = 2 * this.random() - 1;
          v = 2 * this.random() - 1;
          s = u * u + v * v;
        }
        w = sqrt(-2 * (log(s)) / s);
        z = u * w;
        this._next_gauss = v * w;
      }
      return mu + z * sigma;
    };

    BaseRandom.prototype.normalvariate = BaseRandom.prototype.gauss;

    BaseRandom.prototype.triangular = function(low, high, mode) {
      var c, u;
      if (low == null) {
        high = 1;
        low = 0;
      } else if (high == null) {
        high = low;
        low = 0;
      }
      if (mode == null) {
        c = 0.5;
      } else {
        c = (mode - low) / (high - low);
      }
      u = this.random();
      if (u <= c) {
        return low + (high - low) * sqrt(u * c);
      } else {
        return high - (high - low) * sqrt((1 - u) * (1 - c));
      }
    };

    BaseRandom.prototype.lognormvariate = function(mu, sigma) {
      return exp(this.normalvariate(mu, sigma));
    };

    BaseRandom.prototype.expovariate = function(lambda) {
      return (-log(1 - this.random())) / lambda;
    };

    TAU = 2 * Math.PI;

    BaseRandom.prototype.vonmisesvariate = function(mu, kappa) {
      var a, b, c, f, r, rand, u1, u2, u3, z;
      rand = this.random;
      if (kappa <= 1e-6) {
        return TAU * rand();
      }
      a = 1 + sqrt(1 + 4 * kappa * kappa);
      b = (1 - sqrt(2)) * a / 2 / kappa;
      r = (1 + b * b) / 2 / b;
      while (true) {
        u1 = rand();
        z = cos(TAU * u1 / 2);
        f = (1 + r * z) / (r + z);
        c = kappa * (r - f);
        u2 = rand();
        if (u2 < c * (2 - c) || u2 <= c * exp(1 - c)) {
          break;
        }
      }
      u3 = rand();
      return (mod(mu, TAU)) + (u3 > 0.5 ? acos(f) : -acos(f));
    };

    LOG4 = log(4);

    SG_MAGICCONST = 1 + log(4.5);

    E = {
      Math: Math
    };

    BaseRandom.prototype.gammavariate = function(alpha, beta) {
      var ainv, b, bbb, ccc, p, r, rand, u, u1, u2, v, x, z;
      rand = this.random;
      if (alpha > 1) {
        ainv = sqrt(2 * alpha - 1);
        bbb = alpha - LOG4;
        ccc = alpha + ainv;
        while (true) {
          u1 = rand();
          if (!((1e-7 < u1 && u1 < 1 - 1e-7))) {
            continue;
          }
          u2 = 1 - rand();
          v = (log(u1 / (1 - u1))) / ainv;
          x = alpha * exp(v);
          z = u1 * u1 * u2;
          r = bbb + ccc * v - x;
          if (r + SG_MAGICCONST - 4.5 * z >= 0.0 || r >= log(z)) {
            break;
          }
        }
        return beta * x;
      } else if (alpha === 1) {
        while (true) {
          u = rand();
          if (u > 1e-7) {
            break;
          }
        }
        return -beta * log(u);
      } else {
        while (true) {
          u1 = rand();
          b = (E + alpha) / E;
          p = b * u1;
          u2 = rand();
          if (p > 1) {
            x = -log((b - p) / alpha);
            if (u2 <= pow(x, alpha - 1)) {
              break;
            }
          } else {
            x = pow(p, 1 / alpha);
            if (u2 <= exp(-x)) {
              break;
            }
          }
        }
        return beta * x;
      }
    };

    BaseRandom.prototype.betavariate = function(alpha, beta) {
      var y;
      y = this.gammavariate(alpha, 1);
      if (y === 0) {
        return 0;
      } else {
        return y / (y + this.gammavariate(beta, 1));
      }
    };

    BaseRandom.prototype.paretovariate = function(alpha) {
      var u;
      u = 1 - this.random();
      return 1 / (pow(u, 1 / alpha));
    };

    BaseRandom.prototype.weibullvariate = function(alpha, beta) {
      var u;
      u = 1 - this.random();
      return alpha * (pow(-log(u, 1 / beta)));
    };

    return BaseRandom;

  })();

  Random = (function(superClass) {
    extend1(Random, superClass);

    function Random() {
      return Random.__super__.constructor.apply(this, arguments);
    }

    Random.prototype._randint32 = function() {
      var z;
      this.x = 62904 * (this.x & 0xffff) + (this.x >>> 16);
      this.y = 41874 * (this.y & 0xffff) + (this.y >>> 16);
      z = (this.x << 16) + this.y;
      z ^= z >>> 13;
      z ^= z << 17;
      z ^= z >>> 5;
      return z;
    };

    Random.prototype._seed = function(j) {
      this.x = 3395989511 ^ j;
      return this.y = 1716319410 ^ j;
    };

    Random.prototype._getstate = function() {
      return [this.x, this.y];
    };

    Random.prototype._setstate = function(arg) {
      this.x = arg[0], this.y = arg[1];
    };

    return Random;

  })(BaseRandom);

  HighQualityRandom = (function(superClass) {
    extend1(HighQualityRandom, superClass);

    function HighQualityRandom() {
      return HighQualityRandom.__super__.constructor.apply(this, arguments);
    }

    HighQualityRandom.prototype._randint32 = function() {
      var v, x, y;
      x = this.u = this.u * 2891336453 + 1640531513;
      v = this.v;
      v ^= v >>> 13;
      v ^= v << 17;
      v ^= v >>> 5;
      this.v = v;
      y = this.w1 = 33378 * (this.w1 & 0xffff) + (this.w1 >>> 16);
      this.w2 = 57225 * (this.w2 & 0xffff) + (this.w2 >>> 16);
      x ^= x << 9;
      x ^= x >>> 17;
      x ^= x << 6;
      y ^= y << 17;
      y ^= y >>> 15;
      y ^= y << 5;
      return (x + v) ^ (y + this.w2);
    };

    HighQualityRandom.prototype._seed = function(j) {
      this.w1 = 521288629;
      this.w2 = 362436069;
      return this.v = this.u = j ^ 2244614371;
    };

    HighQualityRandom.prototype._getstate = function() {
      return [this.u, this.v, this.w1, this.w2];
    };

    HighQualityRandom.prototype._setstate = function(arg) {
      this.u = arg[0], this.v = arg[1], this.w1 = arg[2], this.w2 = arg[3];
    };

    return HighQualityRandom;

  })(BaseRandom);

  BuiltinRandom = (function(superClass) {
    var _lowbits, _rand;

    extend1(BuiltinRandom, superClass);

    function BuiltinRandom() {
      this._seed = bind1(this._seed, this);
      return BuiltinRandom.__super__.constructor.apply(this, arguments);
    }

    BuiltinRandom.prototype._seed = function(j) {};

    _rand = Math.random;

    _lowbits = function() {
      return (_rand() * pow(2, 64)) | 0;
    };

    if (_lowbits() | _lowbits() | _lowbits()) {
      ({
        random: _rand
      });
    } else {
      ({
        random: function() {
          return _rand() * POW_NEG_32 + _rand();
        }
      });
    }

    BuiltinRandom.prototype._randint32 = function() {
      return (_rand() * POW_32) | 0;
    };

    return BuiltinRandom;

  })(BaseRandom);

  exports = exports || window || this;

  extend(exports, {
    NotImplementedError: NotImplementedError,
    BaseRandom: BaseRandom,
    Random: Random,
    HighQualityRandom: HighQualityRandom,
    BuiltinRandom: BuiltinRandom
  });

  random = new Random;

  ExtMath = (function(superClass) {
    extend1(ExtMath, superClass);

    function ExtMath() {
      return ExtMath.__super__.constructor.apply(this, arguments);
    }

    ExtMath.round = function(x, precision) {
      var scale;
      if (precision == null) {
        precision = 0;
      }
      scale = Math.pow(10, precision);
      return Math.round(x * scale) / scale;
    };

    return ExtMath;

  })(Math);

  if ((base = Array.prototype).shuffle == null) {
    base.shuffle = function() {
      var i, j, l, ref, ref1;
      if (this.length > 1) {
        for (i = l = ref = this.length - 1; ref <= 1 ? l <= 1 : l >= 1; i = ref <= 1 ? ++l : --l) {
          j = Math.floor(Math.random() * (i + 1));
          ref1 = [this[j], this[i]], this[i] = ref1[0], this[j] = ref1[1];
        }
      }
      return this;
    };
  }

  Renderer = (function() {
    Renderer.prototype.drawingContext = null;

    function Renderer(config) {
      this.config = config;
      this.clearScreen = bind1(this.clearScreen, this);
    }

    Renderer.prototype.createDrawingContext = function() {
      this.canvas = document.createElement('canvas');
      document.body.appendChild(this.canvas);
      this.canvas.style.display = "block";
      this.canvas.style.margin = "0 auto";
      this.canvas.style.padding = "0";
      this.canvas.width = 1000;
      this.canvas.height = 600;
      this.drawingContext = this.canvas.getContext('2d');
      this.drawingContext.font = this.config.instructionFontSize + "px " + this.config.fontFamily;
      return this.drawingContext.textAlign = "center";
    };

    Renderer.prototype.renderText = function(text, color, shiftx, shifty, size) {
      if (color == null) {
        color = "black";
      }
      if (shiftx == null) {
        shiftx = 0;
      }
      if (shifty == null) {
        shifty = 0;
      }
      if (size == null) {
        size = e.config.instructionFontSize;
      }
      this.drawingContext.font = size + "px " + this.config.fontFamily + " ";
      return this.fillTextMultiLine(this.drawingContext, text, this.canvas.width / 2 + shiftx, this.canvas.height / 2 + shifty, color);
    };

    Renderer.prototype.fillTextMultiLine = function(ctx, text, x, y, color) {
      var l, len, line, lineHeight, lines, results;
      lineHeight = ctx.measureText("M").width * 1.4;
      lines = text.split("\n");
      ctx.fillStyle = color;
      results = [];
      for (l = 0, len = lines.length; l < len; l++) {
        line = lines[l];
        ctx.fillText(line, x, y);
        results.push(y += lineHeight);
      }
      return results;
    };

    Renderer.prototype.renderCircle = function(x, y, radius, fill, color) {
      if (fill == null) {
        fill = true;
      }
      if (color == null) {
        color = "black";
      }
      this.drawingContext.strokeStyle = 'color';
      this.drawingContext.beginPath();
      this.drawingContext.arc(x, y, radius, 0, 2 * Math.PI, false);
      this.drawingContext.fillStyle = 'white';
      if (fill) {
        this.drawingContext.fillStyle = color;
        this.drawingContext.fill();
      }
      this.drawingContext.lineWidth = 1;
      return this.drawingContext.stroke();
    };

    Renderer.prototype.renderDots = function(stim, color, shiftX, shiftY, radius, sep) {
      var centerx, centery, i, l, len, offset, offsets, results;
      if (color == null) {
        color = "black";
      }
      if (shiftX == null) {
        shiftX = 0;
      }
      if (shiftY == null) {
        shiftY = 0;
      }
      if (radius == null) {
        radius = 10;
      }
      if (sep == null) {
        sep = 20;
      }
      centerx = this.canvas.width / 2 + shiftX;
      centery = this.canvas.height / 2 + shiftY - sep;
      offsets = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
      results = [];
      for (i = l = 0, len = offsets.length; l < len; i = ++l) {
        offset = offsets[i];
        results.push(this.renderCircle(centerx + offset[0] * sep, centery + offset[1] * sep, radius, stim[i], color));
      }
      return results;
    };

    Renderer.prototype.clearScreen = function() {
      return this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Renderer;

  })();

  window.utils = {};

  utils.sampleRetentionInterval = function(means, sd) {
    var m, ri;
    m = random.sample(means, 1)[0];
    ri = random.gauss(m, sd);
    ri = ri < 0 ? 0 : ri;
    return ri;
  };

  Trial = (function() {
    Trial.prototype.startTime = null;

    Trial.prototype.rt = null;

    Trial.prototype.acc = null;

    Trial.prototype.ri = null;

    Trial.prototype.bonus = null;

    Trial.prototype.next = null;

    Trial.prototype.timeout = null;

    Trial.prototype.myState = null;

    Trial.prototype.handleSpacebar = function(event) {
      if (event.keyCode === 32) {
        removeEventListener("keydown", this.handleSpacebar);
        return e.doNext();
      }
    };

    Trial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.trialIdGlobal,
        "blockID": e.state.blockId,
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "ri": this.ri,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": this.bonus,
        "dollars": this.bonus / e.config.pointsPerDollar
      });
    };

    Trial.prototype.handleButtonPress = function(event) {
      var ref;
      if (ref = event.keyCode, indexOf.call(this.keys, ref) >= 0) {
        removeEventListener("keydown", this.handleButtonPress);
        this.rt = performance.now() - this.startTime;
        this.acc = event.keyCode === this.cresp ? 1 : 0;
        this.computeBonus();
        clearTimeout(this.timeout);
        this.recordTrial();
        return this.showFeedback();
      }
    };

    function Trial(context, target1, renderFunc, contextItem, targetItem, keys, cresp, contextColor, targetColor) {
      this.context = context;
      this.target = target1;
      this.renderFunc = renderFunc;
      this.contextItem = contextItem;
      this.targetItem = targetItem;
      this.keys = keys;
      this.cresp = cresp;
      this.contextColor = contextColor != null ? contextColor : "black";
      this.targetColor = targetColor != null ? targetColor : "black";
      this.run = bind1(this.run, this);
      this.enableInput = bind1(this.enableInput, this);
      this.showFeedback = bind1(this.showFeedback, this);
      this.timedOut = bind1(this.timedOut, this);
      this.computeBonus = bind1(this.computeBonus, this);
      this.handleButtonPress = bind1(this.handleButtonPress, this);
      this.recordTrial = bind1(this.recordTrial, this);
      this.handleSpacebar = bind1(this.handleSpacebar, this);
    }

    Trial.prototype.computeBonus = function() {
      this.bonus = this.acc === 1 ? e.config.correctPoints : -e.config.inaccPenalty;
      this.bonus = this.bonus - this.rt * e.config.penaltyPerSecond / 1000;
      e.state.blockBonus = e.state.blockBonus + this.bonus;
      return e.state.globalBonus = e.state.globalBonus + this.bonus;
    };

    Trial.prototype.timedOut = function() {
      r.clearScreen();
      r.renderText("Timed out! You lose " + (e.config.deadline * e.config.penaltyPerSecond + e.config.inaccPenalty) + " points! \n\n Press spacebar to continue.");
      this.bonus = -e.config.deadline * e.config.penaltyPerSecond - e.config.inaccPenalty;
      e.state.blockBonus = e.state.blockBonus + this.bonus;
      e.state.globalBonus = e.state.globalBonus + this.bonus;
      removeEventListener("keydown", this.handleButtonPress);
      this.recordTrial();
      return addEventListener("keydown", this.handleSpacebar);
    };

    Trial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        r.renderText("Correct! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points!");
      } else {
        r.renderText("Incorrect! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points!");
      }
      setTimeout((function() {
        return r.renderText("Press the spacebar to continue.", "black", 0, 180);
      }), e.config.spacebarTimeout);
      return setTimeout(((function(_this) {
        return function() {
          return addEventListener("keydown", _this.handleSpacebar);
        };
      })(this)), e.config.spacebarTimeout);
    };

    Trial.prototype.enableInput = function() {
      addEventListener("keydown", this.handleButtonPress);
      return this.timeout = setTimeout(this.timedOut, e.config.deadline * 1000);
    };

    Trial.prototype.run = function(state) {
      r.clearScreen();
      this.ri = utils.sampleRetentionInterval(e.config.riMeans, e.config.riSD);
      this.startTime = performance.now() + this.ri + e.config.contextDur;
      this.renderFunc(this.contextItem, this.contextColor);
      setTimeout(r.clearScreen, e.config.contextDur);
      setTimeout(((function(_this) {
        return function() {
          return _this.renderFunc(_this.targetItem, _this.targetColor);
        };
      })(this)), this.ri + e.config.contextDur);
      return setTimeout(this.enableInput, this.ri + e.config.contextDur);
    };

    return Trial;

  })();

  PracticeTrial = (function(superClass) {
    extend1(PracticeTrial, superClass);

    function PracticeTrial() {
      this.showFeedback = bind1(this.showFeedback, this);
      this.recordTrial = bind1(this.recordTrial, this);
      this.computeBonus = bind1(this.computeBonus, this);
      this.enableInput = bind1(this.enableInput, this);
      return PracticeTrial.__super__.constructor.apply(this, arguments);
    }

    PracticeTrial.prototype.enableInput = function() {
      return addEventListener("keydown", this.handleButtonPress);
    };

    PracticeTrial.prototype.computeBonus = function() {};

    PracticeTrial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.trialIdGlobal,
        "blockID": "Practice",
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": 0,
        "dollars": 0
      });
    };

    PracticeTrial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        r.renderText("Correct!", "green");
      } else {
        r.renderText("Incorrect!", "red");
      }
      setTimeout((function() {
        return r.renderText("Press the spacebar to continue.", "black", 0, 180);
      }), e.config.spacebarTimeout);
      return setTimeout(((function(_this) {
        return function() {
          return addEventListener("keydown", _this.handleSpacebar);
        };
      })(this)), e.config.spacebarTimeout);
    };

    return PracticeTrial;

  })(Trial);

  TestTrial = (function(superClass) {
    extend1(TestTrial, superClass);

    function TestTrial() {
      this.showFeedback = bind1(this.showFeedback, this);
      this.recordTrial = bind1(this.recordTrial, this);
      return TestTrial.__super__.constructor.apply(this, arguments);
    }

    TestTrial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.testId,
        "blockID": "Test",
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": 0,
        "dollars": 0
      });
    };

    TestTrial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        e.state.currentStreak = e.state.currentStreak + 1;
        r.renderText("Correct (Streak: " + e.state.currentStreak + ")! (" + (e.config.nTestAttempts - e.state.testId - 1) + " attempts left)\n");
      } else {
        e.state.currentStreak = 0;
        r.renderText("Incorrect! (" + (e.config.nTestAttempts - e.state.testId - 1) + " attempts left).\n As a reminder, here are the rules: ", "black", 0, -150);
        e.renderRules(0, -60);
      }
      setTimeout((function() {
        return r.renderText("Press the spacebar to continue.", "black", 0, 180);
      }), e.config.spacebarTimeout);
      return setTimeout(((function(_this) {
        return function() {
          return addEventListener("keydown", _this.handleSpacebar);
        };
      })(this)), e.config.spacebarTimeout);
    };

    return TestTrial;

  })(PracticeTrial);

  Experiment = (function() {
    Experiment.prototype.state = null;

    Experiment.prototype.config = null;

    function Experiment(config) {
      this.config = config;
      this.endExperimentFail = bind1(this.endExperimentFail, this);
      this.endExperimentTrials = bind1(this.endExperimentTrials, this);
      this.endExperimentMoney = bind1(this.endExperimentMoney, this);
      this.endExperiment = bind1(this.endExperiment, this);
      this.handleSpacebar = bind1(this.handleSpacebar, this);
      this.state = {
        blockId: 0,
        trialIdGlobal: 0,
        aPraxId: 0,
        bPraxId: 0,
        testId: 0,
        blockBonus: 0,
        globalBonus: 0,
        currentStreak: 0,
        phase: "initialInstructions"
      };
      this.config.nTrials = this.config.blockSize * this.config.nBlocks;
      this.config.payoffId = this.createInitialState;
      r.createDrawingContext();
      this.createTrialTypes();
      this.shuffleTrials();
    }

    Experiment.prototype.updateBonusAndSave = function() {
      return psiTurk.computeBonus('compute_bonus', function() {
        return psiTurk.saveData();
      });
    };

    Experiment.prototype.shuffleTrials = function() {
      var i, l, len, o, ref, tc, td, trialCounts;
      trialCounts = (function() {
        var l, len, ref, results;
        ref = this.config.trialDist;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          td = ref[l];
          results.push(td * this.config.nTrials);
        }
        return results;
      }).call(this);
      this.trialOrder = [];
      for (i = l = 0, len = trialCounts.length; l < len; i = ++l) {
        tc = trialCounts[i];
        for (o = 1, ref = tc; 1 <= ref ? o <= ref : o >= ref; 1 <= ref ? o++ : o--) {
          this.trialOrder = this.trialOrder.concat(i);
        }
      }
      return this.trialOrder.shuffle();
    };

    Experiment.prototype.handleSpacebar = function(event) {
      if (event.keyCode === 32) {
        removeEventListener("keydown", this.handleSpacebar);
        this.state.instructionSlide = this.state.instructionSlide + 1;
        return this.showInstructions();
      }
    };

    Experiment.prototype.setState = function(state) {
      return this.state = state;
    };

    Experiment.prototype.run = function() {
      return this.doNext();
    };

    Experiment.prototype.doNext = function() {
      r.clearScreen();
      switch (this.state.phase) {
        case "initialInstructions":
          this.state.instructionSlide = 0;
          return this.showInstructions();
        case "APractice":
          this.state.aPraxId = this.state.aPraxId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.aPraxId < this.config.nPraxTrials) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.praxTrialTypes[_this.aPrax[_this.state.aPraxId]].run();
              };
            })(this)), this.config.iti);
          } else {
            this.state.instructionSlide = 4;
            return this.showInstructions();
          }
          break;
        case "BPractice":
          this.state.bPraxId = this.state.bPraxId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.bPraxId < this.config.nPraxTrials) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.praxTrialTypes[_this.bPrax[_this.state.bPraxId]].run();
              };
            })(this)), this.config.iti);
          } else {
            this.state.instructionSlide = 6;
            return this.showInstructions();
          }
          break;
        case "test":
          this.state.testId = this.state.testId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.currentStreak === this.config.testStreakToPass) {
            psiTurk.recordUnstructuredData("trialsToLearn", this.state.testId);
            this.state.instructionSlide = 8;
            return this.showInstructions();
          } else if (this.state.testId < this.config.nTestAttempts) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.testTrialTypes[_this.testTrialOrder[_this.state.testId]].run();
              };
            })(this)), this.config.iti);
          } else {
            return this.endExperimentFail();
          }
          break;
        case "experiment":
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.trialIdGlobal === this.config.nTrials) {
            return this.endExperimentTrials();
          } else if ((this.state.globalBonus / this.config.pointsPerDollar) >= this.config.maxBonus) {
            return this.endExperimentMoney();
          } else if ((modulo(this.state.trialIdGlobal, this.config.blockSize)) === 0) {
            this.state.blockId = this.state.blockId + 1;
            return this.blockFeedback();
          } else {
            return setTimeout(((function(_this) {
              return function() {
                return _this.trialTypes[_this.trialOrder[_this.state.trialIdGlobal]].run();
              };
            })(this)), this.config.iti);
          }
      }
    };

    Experiment.prototype.endExperiment = function(event) {
      removeEventListener("keydown", this.endExperiment);
      return psiTurk.showPage('debriefing.html');
    };

    Experiment.prototype.endExperimentMoney = function() {
      r.clearScreen();
      r.renderText("Congratulations! You have achieved the maximum possible bonus.\n You will be paid $" + (this.config.minPayment + this.config.maxBonus) + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + ".\n Please press any key to continue.");
      psiTurk.recordUnstructuredData('expEndReason', 'maxMoney');
      return addEventListener("keydown", this.endExperiment);
    };

    Experiment.prototype.endExperimentTrials = function() {
      var cashBonus;
      r.clearScreen();
      cashBonus = this.state.globalBonus < 0 ? 0 : ExtMath.round(this.state.globalBonus / this.config.pointsPerDollar, 2);
      r.renderText("Thank you! This concludes the experiment.\n Based on achieving " + (ExtMath.round(this.state.globalBonus, 2)) + " points,\n you will be paid $" + cashBonus + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + ".\n Please press any key to continue.");
      psiTurk.recordUnstructuredData('expEndReason', 'trials');
      return addEventListener("keydown", this.endExperiment);
    };

    Experiment.prototype.endExperimentFail = function() {
      r.clearScreen();
      r.renderText("Unfortunately, you were unable to get " + this.config.testStreakToPass + " correct in a row.\n This means that you cannot continue with the experiment.\n You will receive $" + this.config.minPayment + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + ".\n Please press any key to continue.");
      return addEventListener("keydown", this.endExperiment);
    };

    Experiment.prototype.startExperiment = function() {
      this.state.phase = "experiment";
      psiTurk.finishInstructions();
      this.state.trialIdGlobal = 0;
      this.state.globalBonus = 0;
      this.state.bloclBonus = 0;
      return this.trialTypes[this.trialOrder[0]].run();
    };

    Experiment.prototype.blockFeedback = function() {
      var feedbackText;
      r.clearScreen();
      feedbackText = "Done with this block! \n Your bonus for this block was " + (ExtMath.round(this.state.blockBonus, 2)) + "!\n Your bonus for the experiment so far is " + (ExtMath.round(this.state.globalBonus, 2)) + "!\n Please take a short break.\n The experiment will continue in " + this.config.blockRestDur + " seconds.";
      r.renderText(feedbackText);
      this.state.blockBonus = 0;
      setTimeout(((function(_this) {
        return function() {
          return _this.trialTypes[_this.trialOrder[_this.state.trialIdGlobal]].run(_this);
        };
      })(this)), this.config.blockRestDur * 1000);
      return this.updateBonusAndSave();
    };

    Experiment.prototype.showInstructions = function() {
      switch (this.state.instructionSlide) {
        case 0:
          r.renderText("Welcome to the experiment!\n In this experiment, you will press keys based on pairs of " + this.stimsName + ".\n The two " + this.stimsName + " in each pair will be separated by a blank screen.\n There will be one correct key for each pair of " + this.stimsName + ".\n\n", "black", 0, -200);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 0);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 1:
          r.clearScreen();
          r.renderText("First, you will learn the rules mapping " + this.stimsName + " to keys.\n Then, we will test that you learned the mappings.\n If you fail, the HIT will end and you will earn the minimum payment ($" + this.config.minPayment + ").\n If you succeed, you will compete for an additional bonus of up to $" + this.config.maxBonus + ".\n You response keys will be '4' and '8'. \n You should put your left index finger on '4' and right index finger on '8' now. \n\n", "black", 0, -200);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 100);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 2:
          r.clearScreen();
          r.renderText("Here is the first rule:\n followed by      -->  press the '4' key\n followed by      -->  press the '8' key\n\n Now you will get a chance to practice.", "black", 0, -200);
          this.renderStimInstruct(this.stimuli[0], "blue", -250, -165);
          this.renderStimInstruct(this.stimuli[1], "green", -50, -165);
          this.renderStimInstruct(this.stimuli[0], "blue", -250, -130);
          this.renderStimInstruct(this.stimuli[2], "green", -50, -130);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 0);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 3:
          this.state.phase = "APractice";
          return this.praxTrialTypes[this.aPrax[0]].run();
        case 4:
          r.clearScreen();
          r.renderText("Here is the second rule:\n followed by      -->  press the '4' key\n followed by      -->  press the '8' key\n\n Now you will get a chance to practice.", "black", 0, -200);
          this.renderStimInstruct(this.stimuli[3], "blue", -250, -165);
          this.renderStimInstruct(this.stimuli[2], "green", -50, -165);
          this.renderStimInstruct(this.stimuli[3], "blue", -250, -130);
          this.renderStimInstruct(this.stimuli[1], "green", -50, -130);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 0);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 5:
          this.state.phase = "BPractice";
          return this.praxTrialTypes[this.bPrax[0]].run();
        case 6:
          r.clearScreen();
          r.renderText("Now, we will test that you have learned the rules.\n You will see a sequence of trials. Your goal is to get " + this.config.testStreakToPass + " correct in a row.\n You will have " + this.config.nTestAttempts + " trials total. If you get " + this.config.testStreakToPass + " correct in a row, you can compete\n for a bonus of up to $" + this.config.maxBonus + ". If you get to " + this.config.nTestAttempts + " without getting " + this.config.testStreakToPass + " in a row, \n the HIT will end and you will get the minimum payment ($" + this.config.minPayment + ").\n\n As a reminder, here are the rules: \n", "black", 0, -200);
          this.renderRules(0, 60);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 230);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 7:
          r.clearScreen();
          this.state.phase = "test";
          return this.testTrialTypes[this.testTrialOrder[0]].run();
        case 8:
          r.clearScreen();
          r.renderText("Congratulations! You have learned the rules.\n You will now see up to " + this.config.nTrials + " more trials in blocks of " + this.config.blockSize + ".\n You will get " + this.config.correctPoints + " points for a correct repsonse.\n If you do not respond in " + this.config.deadline + " seconds, the experiment will  \n just continue to the next trial and you will not gain points.\n You will receive $1 for each " + this.config.pointsPerDollar + " points.\n Your points can be negative but you cannot lose your $" + this.config.minPayment + " baseline.\n The HIT will end when you have done " + this.config.nTrials + " trials.\n \n \n", "black", 0, -260);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 100);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 9:
          r.clearScreen();
          r.renderText("As a reminder, here are the rules:", "black", 0, -200);
          this.renderRules(0, -150);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 100);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 10:
          r.clearScreen();
          return this.startExperiment();
      }
    };

    Experiment.prototype.renderRules = function(xoffset, yoffset) {
      if (xoffset == null) {
        xoffset = 0;
      }
      if (yoffset == null) {
        yoffset = 0;
      }
      r.renderText("followed by      -->  press the '4' key\n followed by      -->  press the '4' key\n followed by      -->  press the '8' key\n followed by      -->  press the '8' key", "black", xoffset, yoffset);
      this.renderStimInstruct(e.stimuli[0], "blue", -250 + xoffset, 105 + yoffset);
      this.renderStimInstruct(e.stimuli[2], "green", -50 + xoffset, 105 + yoffset);
      this.renderStimInstruct(e.stimuli[0], "blue", -250 + xoffset, 35 + yoffset);
      this.renderStimInstruct(e.stimuli[1], "green", -50 + xoffset, 35 + yoffset);
      this.renderStimInstruct(e.stimuli[3], "blue", -250 + xoffset, 70 + yoffset);
      this.renderStimInstruct(e.stimuli[1], "green", -50 + xoffset, 70 + yoffset);
      this.renderStimInstruct(e.stimuli[3], "blue", -250 + xoffset, 0 + yoffset);
      return this.renderStimInstruct(e.stimuli[2], "green", -50 + xoffset, 0 + yoffset);
    };

    Experiment.prototype.createTrialTypes = function() {
      var aa, ab, i, l, len, len1, len2, o, pc, praxCounts, q, ref, ref1, ref2, t, tc, testCounts;
      this.stimuli.shuffle();
      this.trialTypes = [new Trial("A", "X", this.renderStimTrial, this.stimuli[0], this.stimuli[1], [52, 56], 52, "blue", "green"), new Trial("A", "Y", this.renderStimTrial, this.stimuli[0], this.stimuli[2], [52, 56], 56, "blue", "green"), new Trial("B", "X", this.renderStimTrial, this.stimuli[3], this.stimuli[1], [52, 56], 56, "blue", "green"), new Trial("B", "Y", this.renderStimTrial, this.stimuli[3], this.stimuli[2], [52, 56], 52, "blue", "green")];
      this.praxTrialTypes = [new PracticeTrial("A", "X", this.renderStimTrial, this.stimuli[0], this.stimuli[1], [52, 56], 52, "blue", "green"), new PracticeTrial("A", "Y", this.renderStimTrial, this.stimuli[0], this.stimuli[2], [52, 56], 56, "blue", "green"), new PracticeTrial("B", "X", this.renderStimTrial, this.stimuli[3], this.stimuli[1], [52, 56], 56, "blue", "green"), new PracticeTrial("B", "Y", this.renderStimTrial, this.stimuli[3], this.stimuli[2], [52, 56], 52, "blue", "green")];
      this.testTrialTypes = [new TestTrial("A", "X", this.renderStimTrial, this.stimuli[0], this.stimuli[1], [52, 56], 52, "blue", "green"), new TestTrial("A", "Y", this.renderStimTrial, this.stimuli[0], this.stimuli[2], [52, 56], 56, "blue", "green"), new TestTrial("B", "X", this.renderStimTrial, this.stimuli[3], this.stimuli[1], [52, 56], 56, "blue", "green"), new TestTrial("B", "Y", this.renderStimTrial, this.stimuli[3], this.stimuli[2], [52, 56], 52, "blue", "green")];
      praxCounts = (function() {
        var l, results;
        results = [];
        for (i = l = 1; l <= 2; i = ++l) {
          results.push(this.config.nPraxTrials / 2);
        }
        return results;
      }).call(this);
      this.aPrax = [];
      this.bPrax = [];
      for (i = l = 0, len = praxCounts.length; l < len; i = ++l) {
        pc = praxCounts[i];
        for (o = 1, ref = pc; 1 <= ref ? o <= ref : o >= ref; 1 <= ref ? o++ : o--) {
          this.aPrax = this.aPrax.concat(i);
        }
      }
      for (i = q = 0, len1 = praxCounts.length; q < len1; i = ++q) {
        pc = praxCounts[i];
        for (t = 1, ref1 = pc; 1 <= ref1 ? t <= ref1 : t >= ref1; 1 <= ref1 ? t++ : t--) {
          this.bPrax = this.bPrax.concat(i + 2);
        }
      }
      this.aPrax.shuffle();
      this.bPrax.shuffle();
      testCounts = (function() {
        var aa, results;
        results = [];
        for (i = aa = 1; aa <= 4; i = ++aa) {
          results.push(this.config.nTestAttempts / 4);
        }
        return results;
      }).call(this);
      this.testTrialOrder = [];
      for (i = aa = 0, len2 = testCounts.length; aa < len2; i = ++aa) {
        tc = testCounts[i];
        for (ab = 1, ref2 = tc; 1 <= ref2 ? ab <= ref2 : ab >= ref2; 1 <= ref2 ? ab++ : ab--) {
          this.testTrialOrder = this.testTrialOrder.concat(i);
        }
      }
      return this.testTrialOrder.shuffle();
    };

    return Experiment;

  })();

  LettersExperiment = (function(superClass) {
    extend1(LettersExperiment, superClass);

    function LettersExperiment() {
      this.renderStimTrial = bind1(this.renderStimTrial, this);
      return LettersExperiment.__super__.constructor.apply(this, arguments);
    }

    LettersExperiment.prototype.stimsName = "letters";

    LettersExperiment.prototype.stimuli = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

    LettersExperiment.prototype.renderStimInstruct = function(stim, colour, xoffset, yoffset) {
      if (colour == null) {
        colour = "black";
      }
      if (xoffset == null) {
        xoffset = 0;
      }
      if (yoffset == null) {
        yoffset = 0;
      }
      return r.renderText(stim, colour, xoffset, yoffset);
    };

    LettersExperiment.prototype.renderStimTrial = function(stim, colour, xoffset, yoffset) {
      if (colour == null) {
        colour = "black";
      }
      if (xoffset == null) {
        xoffset = 0;
      }
      if (yoffset == null) {
        yoffset = 0;
      }
      return r.renderText(stim, colour, xoffset, yoffset, e.config.taskFontSize);
    };

    return LettersExperiment;

  })(Experiment);

  DotsExperiment = (function(superClass) {
    extend1(DotsExperiment, superClass);

    function DotsExperiment() {
      return DotsExperiment.__super__.constructor.apply(this, arguments);
    }

    DotsExperiment.prototype.stimsName = "dots";

    DotsExperiment.prototype.stimuli = [[0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0]];

    DotsExperiment.prototype.renderStimInstruct = function(stim, colour, xoffset, yoffset) {
      if (colour == null) {
        colour = "black";
      }
      if (xoffset == null) {
        xoffset = 0;
      }
      if (yoffset == null) {
        yoffset = 0;
      }
      return r.renderDots(stim, colour, xoffset, yoffset, 5, 7);
    };

    DotsExperiment.prototype.renderStimTrial = function(stim, colour, xoffset, yoffset) {
      if (colour == null) {
        colour = "black";
      }
      if (xoffset == null) {
        xoffset = 0;
      }
      if (yoffset == null) {
        yoffset = 0;
      }
      return r.renderDots(stim, colour, xoffset, yoffset, 15, 20);
    };

    return DotsExperiment;

  })(Experiment);

  window.Experiment = LettersExperiment;

  window.Renderer = Renderer;

}).call(this);
